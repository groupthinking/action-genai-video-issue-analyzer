/**
 * ACTION Stage Service - Digital Refinery Action Layer
 *
 * Converts video analysis into actionable outputs:
 * 1. GitHub Issues - Implementation tasks from video tutorials
 * 2. Vector Embeddings - For RAG semantic search
 * 3. Webhook Triggers - MCP integrations (future)
 *
 * ARCHITECTURE: Zero-disk, cloud-native actions
 */

import { Octokit } from "@octokit/rest";

// =============================================================================
// Types
// =============================================================================

export interface ActionOutput {
  githubIssue?: GitHubIssueResult;
  embeddings?: EmbeddingResult;
  webhooks?: WebhookResult[];
}

export interface GitHubIssueResult {
  created: boolean;
  issueUrl?: string;
  issueNumber?: number;
  error?: string;
}

export interface EmbeddingResult {
  vectorCount: number;
  segmentIds: string[];
  error?: string;
}

export interface WebhookResult {
  endpoint: string;
  success: boolean;
  statusCode?: number;
  error?: string;
}

export interface AnalysisForAction {
  title: string;
  summary: string;
  techStack: string[];
  implementationSteps: string[];
  codeBlocks: Array<{ language: string; code: string; description?: string }>;
  dependencies: Record<string, string>;
  keyMoments: Array<{ timestamp: string; description: string }>;
}

// =============================================================================
// GitHub Issue Generation
// =============================================================================

/**
 * Create a GitHub issue from video analysis results
 */
export async function createGitHubIssueFromAnalysis(
  analysis: AnalysisForAction,
  options: {
    owner: string;
    repo: string;
    labels?: string[];
    assignees?: string[];
  }
): Promise<GitHubIssueResult> {
  const token = process.env.GITHUB_TOKEN;

  if (!token) {
    return {
      created: false,
      error: "GITHUB_TOKEN not configured",
    };
  }

  try {
    const octokit = new Octokit({ auth: token });

    // Build issue body
    const body = formatIssueBody(analysis);

    const response = await octokit.issues.create({
      owner: options.owner,
      repo: options.repo,
      title: `ðŸ“º Implementation: ${analysis.title}`,
      body,
      labels: options.labels || ["video-tutorial", "implementation"],
      assignees: options.assignees,
    });

    return {
      created: true,
      issueUrl: response.data.html_url,
      issueNumber: response.data.number,
    };
  } catch (error) {
    return {
      created: false,
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Format analysis into GitHub issue markdown
 */
function formatIssueBody(analysis: AnalysisForAction): string {
  const sections: string[] = [];

  // Summary
  sections.push(`## Summary\n\n${analysis.summary}`);

  // Tech Stack
  if (analysis.techStack.length > 0) {
    sections.push(
      `## Tech Stack\n\n${analysis.techStack.map((t) => `- ${t}`).join("\n")}`
    );
  }

  // Dependencies
  const deps = Object.entries(analysis.dependencies);
  if (deps.length > 0) {
    sections.push(
      `## Dependencies\n\n\`\`\`json\n${JSON.stringify(analysis.dependencies, null, 2)}\n\`\`\``
    );
  }

  // Implementation Checklist
  if (analysis.implementationSteps.length > 0) {
    const checklist = analysis.implementationSteps
      .map((step) => `- [ ] ${step}`)
      .join("\n");
    sections.push(`## Implementation Checklist\n\n${checklist}`);
  }

  // Code Blocks
  if (analysis.codeBlocks.length > 0) {
    const codeSection = analysis.codeBlocks
      .map((block) => {
        const header = block.description ? `### ${block.description}\n\n` : "";
        return `${header}\`\`\`${block.language}\n${block.code}\n\`\`\``;
      })
      .join("\n\n");
    sections.push(`## Code Examples\n\n${codeSection}`);
  }

  // Key Moments (timestamps)
  if (analysis.keyMoments.length > 0) {
    const moments = analysis.keyMoments
      .map((m) => `- **${m.timestamp}** - ${m.description}`)
      .join("\n");
    sections.push(`## Key Moments\n\n${moments}`);
  }

  // Footer
  sections.push(
    `---\n\n*Generated by UVAI Digital Refinery â€¢ ${new Date().toISOString()}*`
  );

  return sections.join("\n\n");
}

// =============================================================================
// Vector Embeddings
// =============================================================================

/**
 * Generate and store embeddings for RAG search
 * Uses Vertex AI text-embedding-004 + Cloud SQL pgvector
 */
export async function generateEmbeddings(
  jobId: string,
  analysis: AnalysisForAction
): Promise<EmbeddingResult> {
  // Check if embedding service is available (Cloud SQL connection)
  const useRealEmbeddings = process.env.CLOUDSQL_PASSWORD || process.env.K_SERVICE;

  if (useRealEmbeddings) {
    try {
      // Dynamic import to avoid loading pg when not needed
      const { embedJobAnalysis } = await import("./embedding");

      const result = await embedJobAnalysis(jobId, {
        summary: analysis.summary,
        steps: analysis.implementationSteps,
        insights: analysis.keyMoments.map((m) => m.description),
        codeBlocks: analysis.codeBlocks.map((c) => c.code),
      });

      return {
        vectorCount: result.embeddingCount,
        segmentIds: result.embeddingIds,
      };
    } catch (error) {
      console.warn(`[ACTION] Embedding generation failed, using placeholder: ${error}`);
      // Fall through to placeholder
    }
  }

  // Placeholder when Cloud SQL is not available (local dev without proxy)
  const segments = [
    { id: `${jobId}-summary`, text: analysis.summary },
    ...analysis.implementationSteps.map((step, i) => ({
      id: `${jobId}-step-${i}`,
      text: step,
    })),
    ...analysis.keyMoments.map((m, i) => ({
      id: `${jobId}-moment-${i}`,
      text: m.description,
    })),
  ];

  console.log(`[ACTION] Using placeholder embeddings (${segments.length} segments)`);
  console.log(`[ACTION] Set CLOUDSQL_PASSWORD to enable real pgvector storage`);

  return {
    vectorCount: segments.length,
    segmentIds: segments.map((s) => s.id),
  };
}

// =============================================================================
// Webhook Triggers (placeholder)
// =============================================================================

/**
 * Trigger configured webhooks for downstream automation
 */
export async function triggerWebhooks(
  jobId: string,
  analysis: AnalysisForAction,
  webhookUrls: string[]
): Promise<WebhookResult[]> {
  const results: WebhookResult[] = [];

  for (const url of webhookUrls) {
    try {
      const response = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          jobId,
          analysis,
          timestamp: new Date().toISOString(),
        }),
      });

      results.push({
        endpoint: url,
        success: response.ok,
        statusCode: response.status,
      });
    } catch (error) {
      results.push({
        endpoint: url,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  return results;
}

// =============================================================================
// Main Action Executor
// =============================================================================

/**
 * Execute ACTION stage - convert analysis to outputs
 */
export async function executeAction(
  jobId: string,
  analysis: AnalysisForAction,
  options: {
    createGitHubIssue?: { owner: string; repo: string; labels?: string[] };
    generateVectors?: boolean;
    webhookUrls?: string[];
  }
): Promise<ActionOutput> {
  const output: ActionOutput = {};

  // 1. GitHub Issue
  if (options.createGitHubIssue) {
    output.githubIssue = await createGitHubIssueFromAnalysis(
      analysis,
      options.createGitHubIssue
    );
  }

  // 2. Vector Embeddings
  if (options.generateVectors) {
    output.embeddings = await generateEmbeddings(jobId, analysis);
  }

  // 3. Webhooks
  if (options.webhookUrls && options.webhookUrls.length > 0) {
    output.webhooks = await triggerWebhooks(jobId, analysis, options.webhookUrls);
  }

  return output;
}
